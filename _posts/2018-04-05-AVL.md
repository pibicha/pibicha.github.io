---
title: 数据结构—AVL搜索树
date: 2018-04-05 14:58:00
categories:
- dataStruct
tags:
- [Python,树]
---  

BST在极端情况下，比如按顺序插入1，2，3，4，5，6，7；那么这几个元素都会变成上一个元素的右节点，，这样搜索起来复杂度又变成线性的了；  

在基于BST的约束上，新增了一个约束，来保证树的搜索不会恶化成线性的：
- 根结点的左子树和右子树高度距离不超过1

为了实现上述这一点，基于BST需要进行以下改造：  
1. 在节点上会多记录一个平衡因子的属性，每个节点的平衡因子都是由其直系子节点的左右分配情况而来；比如叶子节点的平衡因子就是0。  
2. 没新增一个节点，需要更新其父节点的平衡因子，递归更新到根结点为止  
3. 如果根结点的平衡因子大于一，需要对树进行旋转：  
3.1 旋转的过程类似于BST寻找继任者的过程，如果树失衡了，需要将根结点及其偏轻的子树与其偏重的子树割；
3.2 偏重的子树会成为新的根，而偏轻的那一根子树，需要在新的根中找到合适的位置插入：  
3.2.1 偏轻的那根树，观其方向，理论上只要取代新的根同一个方向的节点，并将被取代的节点插入到取代后的位置即可；
3.2.2 然而有种特殊的现象，新的根走势为'<'或'>'字型，这样的化会死循环，，  
为了解决这种现象，先将'<'或'>'转为'\'或'/'，这样旋转才能生效；

以上的规则都是由实际的二叉树图表推导的；AVL树基于BST稍微修改即可得到，但是很少用到AVL，每次插入都递归更新向上节点的平衡因子，并且根结点的平衡因子如果大于|1|的话，还要旋转，性能太低；虽然实现了绝对的平衡，但是带来的性能影响太大；  

左旋和右旋比较抽象，实际上就是在BST寻找继任者的基础上改的